import asyncio
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from typing import Dict, Optional, List
import json


class GitLabLogAnalyzer:
    """
    Client for interacting with FastMCP GitLab Log Analyzer (LangChain version)
    """

    def __init__(self, server_script: str = "fastmcp_server_langchain.py"):
        """
        Initialize the client

        Args:
            server_script: Path to the FastMCP server script
        """
        self.server_script = server_script
        self.session = None
        self.read = None
        self.write = None

    async def __aenter__(self):
        """Async context manager entry"""
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.disconnect()

    async def connect(self):
        """Connect to the FastMCP server"""
        server_params = StdioServerParameters(
            command="python",
            args=[self.server_script],
            env=None
        )

        self.read, self.write = await stdio_client(server_params)
        self.session = ClientSession(self.read, self.write)
        await self.session.initialize()

    async def disconnect(self):
        """Disconnect from the server"""
        if self.session:
            await self.session.__aexit__(None, None, None)

    async def list_tools(self) -> List[Dict]:
        """Get list of available tools"""
        if not self.session:
            raise RuntimeError("Not connected. Call connect() first.")

        response = await self.session.list_tools()
        return [
            {
                "name": tool.name,
                "description": tool.description,
                "input_schema": tool.inputSchema
            }
            for tool in response.tools
        ]

    async def call_tool(self, tool_name: str, **kwargs) -> str:
        """
        Call a tool with arguments

        Args:
            tool_name: Name of the tool to call
            **kwargs: Tool arguments

        Returns:
            Tool response as string
        """
        if not self.session:
            raise RuntimeError("Not connected. Call connect() first.")

        result = await self.session.call_tool(tool_name, arguments=kwargs)

        # Extract text content from result
        if result.content:
            for content in result.content:
                if hasattr(content, 'text'):
                    return content.text

        return "No response"

    # Convenience methods for specific analyses

    async def analyze_terraform_init(self, log_content: str) -> str:
        """Analyze Terraform init log section"""
        return await self.call_tool("analyze_terraform_init", log_content=log_content)

    async def analyze_terraform_plan(self, log_content: str) -> str:
        """Analyze Terraform plan log section"""
        return await self.call_tool("analyze_terraform_plan", log_content=log_content)

    async def analyze_terraform_scan(self, log_content: str) -> str:
        """Analyze Terraform security scan results"""
        return await self.call_tool("analyze_terraform_scan", log_content=log_content)

    async def analyze_job_failure(self, log_content: str) -> str:
        """Analyze job failure final status"""
        return await self.call_tool("analyze_job_failure", log_content=log_content)

    async def extract_errors(self, log_content: str) -> str:
        """Extract and categorize errors from log"""
        return await self.call_tool("extract_errors", log_content=log_content)

    async def summarize_pipeline(
            self,
            tf_init: Optional[str] = None,
            tf_plan: Optional[str] = None,
            tf_scan: Optional[str] = None,
            final_status: Optional[str] = None,
            other_sections: Optional[str] = None
    ) -> str:
        """Generate comprehensive pipeline summary"""
        return await self.call_tool(
            "summarize_pipeline",
            tf_init=tf_init,
            tf_plan=tf_plan,
            tf_scan=tf_scan,
            final_status=final_status,
            other_sections=other_sections
        )

    async def get_recommendations(self, analysis_results: str) -> str:
        """Get actionable recommendations based on analysis"""
        return await self.call_tool("get_recommendations", analysis_results=analysis_results)


async def main_async():
    """Async example"""
    async with GitLabLogAnalyzer() as client:
        # List tools
        tools = await client.list_tools()
        print("Available tools:")
        for tool in tools:
            print(f"  - {tool['name']}: {tool['description']}")
        print()

        # Example analysis
        sample_log = """
[0m[1mInitializing the backend...[0m
[0m[32mSuccessfully configured the backend "azurerm"![0m
[0m[1mInitializing provider plugins...[0m
- Installing hashicorp/azurerm v4.34.0...
- Installed hashicorp/azurerm v4.34.0 (signed by HashiCorp)
[0m[1m[32mTerraform has been successfully initialized![0m[32m[0m
        """

        print("Analyzing Terraform init log...")
        analysis = await client.analyze_terraform_init(sample_log)
        print(analysis)


if __name__ == "__main__":
    # Run sync version (easier for most use cases)
    asyncio.run(main_async())